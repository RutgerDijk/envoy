# Envoy Plugin Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build the Envoy Claude Code plugin — a professional .NET/React/Azure development workflow system with handoff-ready artifacts, 4-layer review, and Chrome DevTools visual verification.

**Architecture:** Plugin-based skill system following Claude Code plugin conventions. Skills as markdown files with YAML frontmatter. Stack profiles provide technology-specific best practices that are auto-detected and injected into skill context.

**Tech Stack:** Claude Code plugin (markdown skills, JSON manifest), GitHub CLI for issues, CodeRabbit for static analysis, Chrome DevTools MCP for visual verification.

**Design Document:** `docs/plans/2026-01-17-envoy-plugin-design.md`

---

## Phase 1: Plugin Foundation

### Task 1: Create Plugin Manifest

**Files:**
- Create: `.claude-plugin/plugin.json`

**Step 1: Create plugin directory**

```bash
mkdir -p .claude-plugin
```

**Step 2: Create plugin.json manifest**

```json
{
  "name": "envoy",
  "description": "Professional .NET/React/Azure development workflows with handoff-ready artifacts, 4-layer review, and visual verification",
  "version": "1.0.0",
  "author": {
    "name": "Rutger Dijkstra"
  }
}
```

**Step 3: Verify plugin structure**

```bash
ls -la .claude-plugin/
```

Expected: `plugin.json` exists

**Step 4: Commit**

```bash
git add .claude-plugin/
git commit -m "feat: add Envoy plugin manifest"
```

---

### Task 2: Create Directory Structure

**Files:**
- Create directories: `skills/`, `commands/`, `stacks/`, `agents/`, `templates/`

**Step 1: Create all directories**

```bash
mkdir -p skills commands stacks agents templates
```

**Step 2: Verify structure**

```bash
ls -la
```

Expected: All directories exist alongside `.claude-plugin/`

**Step 3: Add .gitkeep files to preserve empty directories**

```bash
touch skills/.gitkeep commands/.gitkeep stacks/.gitkeep agents/.gitkeep templates/.gitkeep
```

**Step 4: Commit**

```bash
git add skills/ commands/ stacks/ agents/ templates/
git commit -m "feat: add plugin directory structure"
```

---

### Task 3: Create Brainstorming Skill

**Files:**
- Create: `skills/brainstorming/SKILL.md`

**Step 1: Create skill directory**

```bash
mkdir -p skills/brainstorming
```

**Step 2: Create SKILL.md**

```markdown
---
name: brainstorming
description: Turn ideas into fully formed designs with GitHub issues and spec docs. Use when starting any new feature or significant change.
---

# Brainstorming Ideas Into Designs

## Overview

Help turn ideas into fully formed designs through natural collaborative dialogue. Produces two artifacts:
1. **GitHub Issue** — Concise summary with labels and acceptance criteria
2. **Spec Document** — Detailed design in `docs/plans/`

**Announce at start:** "I'm using envoy:brainstorming to design this feature."

## The Process

### Phase 1: Understanding the Idea

1. Check the current project state (files, docs, recent commits)
2. Ask questions **one at a time** to refine the idea
3. Prefer multiple choice questions when possible
4. Focus on: purpose, constraints, success criteria, affected areas

### Phase 2: Exploring Approaches

1. Propose 2-3 different approaches with trade-offs
2. Lead with your recommended option and explain why
3. Get user confirmation before proceeding

### Phase 3: Presenting the Design

1. Present design in sections of 200-300 words
2. Ask after each section: "Does this look right so far?"
3. Cover: architecture, components, data flow, error handling, testing
4. Be ready to revise based on feedback

### Phase 4: Creating Artifacts

**Create Spec Document:**

Save to `docs/plans/YYYY-MM-DD-<topic>-design.md`

**Create GitHub Issue:**

```bash
gh issue create --title "<Feature Name>" --body "$(cat <<'EOF'
## Summary

<2-3 sentence description>

## Labels

`backend` `frontend` `feature` (choose applicable)

## Linked Spec

[View full design](docs/plans/YYYY-MM-DD-<topic>-design.md)

## Quick Start

\`\`\`bash
# Create isolated workspace
git worktree add ../envoy-worktrees/<branch-name> -b feature/<branch-name>
cd ../envoy-worktrees/<branch-name>
claude
/envoy:pickup <issue-number>
\`\`\`

## Acceptance Criteria

- [ ] Criterion 1
- [ ] Criterion 2

## Execution Strategy

`parallel` | `batch` | `sequential`

---

*Generated by Envoy*
EOF
)" --label "<labels>"
```

### Phase 5: Handoff

After creating artifacts, offer:

"**Artifacts created:**
- Spec: `docs/plans/<filename>.md`
- Issue: #<number>

**Next steps:**
1. `/envoy:write-plan` — Create detailed implementation plan
2. Or hand off to another developer with `/envoy:pickup <issue-number>`"

## Labels Reference

| Label | When to Use |
|-------|-------------|
| `backend` | Changes to .NET API, services, database |
| `frontend` | Changes to React UI, components, styling |
| `infrastructure` | Docker, Azure, Bicep, CI/CD |
| `security` | Authentication, authorization, security fixes |
| `feature` | New functionality |
| `refactor` | Code restructuring without behavior change |
| `bugfix` | Fixing broken functionality |
| `docs` | Documentation only |

## Key Principles

- **One question at a time** — Don't overwhelm
- **Multiple choice preferred** — Easier to answer
- **YAGNI ruthlessly** — Remove unnecessary features
- **Artifacts are durable** — Everything survives context loss
```

**Step 3: Verify file created**

```bash
cat skills/brainstorming/SKILL.md | head -20
```

**Step 4: Commit**

```bash
git add skills/brainstorming/
git commit -m "feat(skills): add brainstorming skill"
```

---

### Task 4: Create Brainstorm Command

**Files:**
- Create: `commands/brainstorm.md`

**Step 1: Create command file**

```markdown
---
description: Start a brainstorming session to design a new feature
---

# Brainstorm Command

Use the envoy:brainstorming skill to design the feature described in "$ARGUMENTS".

If no arguments provided, ask: "What would you like to design today?"
```

**Step 2: Verify file created**

```bash
cat commands/brainstorm.md
```

**Step 3: Commit**

```bash
git add commands/brainstorm.md
git commit -m "feat(commands): add brainstorm command"
```

---

### Task 5: Create Writing-Plans Skill

**Files:**
- Create: `skills/writing-plans/SKILL.md`

**Step 1: Create skill directory**

```bash
mkdir -p skills/writing-plans
```

**Step 2: Create SKILL.md**

```markdown
---
name: writing-plans
description: Create detailed implementation plans from specs. Use when you have a design doc and need to break it into executable tasks.
---

# Writing Implementation Plans

## Overview

Create comprehensive implementation plans from design documents. Plans assume the implementing engineer has zero context — document everything needed.

**Announce at start:** "I'm using envoy:writing-plans to create the implementation plan."

## Plan Document Header

Every plan MUST start with:

```markdown
# [Feature Name] Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use envoy:executing-plans to implement this plan task-by-task.

**Goal:** [One sentence describing what this builds]

**Architecture:** [2-3 sentences about approach]

**Tech Stack:** [Key technologies/libraries]

**Design Document:** `docs/plans/<design-doc>.md`

---
```

## Bite-Sized Task Granularity

**Each step is one action (2-5 minutes):**

- "Create the file" — step
- "Add the function" — step
- "Run the test" — step
- "Commit" — step

## Task Structure

```markdown
### Task N: [Component Name]

**Files:**
- Create: `exact/path/to/file.ext`
- Modify: `exact/path/to/existing.ext:123-145`
- Test: `tests/exact/path/to/test.ext`

**Step 1: [Action]**

[Exact code or command]

**Step 2: [Action]**

[Exact code or command]

**Step 3: Verify**

Run: `[exact command]`
Expected: [what should happen]

**Step 4: Commit**

```bash
git add [files]
git commit -m "[type]: [description]"
```
```

## Execution Strategy

Each plan MUST specify an execution strategy:

```yaml
execution:
  strategy: parallel | batch | sequential
  # For batch:
  batches:
    - tasks: [1, 2, 3]
      checkpoint: true
    - tasks: [4, 5]
      checkpoint: false
```

**Choose based on:**
- `parallel` — Independent tasks across different files
- `batch` — Logical phases (data model → API → UI)
- `sequential` — Tightly coupled changes

## After Saving the Plan

Offer execution choice:

"**Plan complete and saved to `docs/plans/<filename>.md`**

**Execution options:**

1. **Subagent-Driven (this session)** — Dispatch fresh agent per task, review between tasks
2. **Parallel Session (separate)** — Open new session with envoy:executing-plans

Which approach?"

## Key Principles

- Exact file paths always
- Complete code in plan (not "add validation")
- Exact commands with expected output
- DRY, YAGNI, TDD where applicable
- Frequent commits
```

**Step 3: Commit**

```bash
git add skills/writing-plans/
git commit -m "feat(skills): add writing-plans skill"
```

---

### Task 6: Create Write-Plan Command

**Files:**
- Create: `commands/write-plan.md`

**Step 1: Create command file**

```markdown
---
description: Create a detailed implementation plan from a design document
---

# Write Plan Command

Use the envoy:writing-plans skill to create an implementation plan.

If "$ARGUMENTS" contains a file path, use that as the design document.
Otherwise, look for the most recent design doc in `docs/plans/` or ask which one to use.
```

**Step 2: Commit**

```bash
git add commands/write-plan.md
git commit -m "feat(commands): add write-plan command"
```

---

### Task 7: Create Using-Git-Worktrees Skill

**Files:**
- Create: `skills/using-git-worktrees/SKILL.md`

**Step 1: Create skill directory**

```bash
mkdir -p skills/using-git-worktrees
```

**Step 2: Create SKILL.md**

```markdown
---
name: using-git-worktrees
description: Create isolated workspaces for feature development. Use when starting implementation to avoid polluting main workspace.
---

# Using Git Worktrees

## Overview

Create isolated git worktrees for feature development. Keeps main workspace clean while allowing parallel work on multiple features.

**Announce at start:** "I'm using envoy:using-git-worktrees to create an isolated workspace."

## Creating a Worktree

**Step 1: Determine worktree location**

Default: `../envoy-worktrees/<branch-name>`

**Step 2: Create worktree with new branch**

```bash
git worktree add ../envoy-worktrees/<branch-name> -b feature/<branch-name>
```

**Step 3: Navigate to worktree**

```bash
cd ../envoy-worktrees/<branch-name>
```

**Step 4: Verify setup**

```bash
git branch --show-current
pwd
```

Expected: On `feature/<branch-name>` in worktree directory

## Naming Conventions

| Type | Pattern | Example |
|------|---------|---------|
| Worktree dir | `../envoy-worktrees/<topic>` | `../envoy-worktrees/user-auth` |
| Branch | `feature/<topic>` | `feature/user-auth` |
| Bugfix branch | `fix/<topic>` | `fix/login-error` |

## Cleanup

After merging, remove the worktree:

```bash
git worktree remove ../envoy-worktrees/<branch-name>
```

## Tips

- One worktree per feature
- Commit frequently in worktrees
- Push to remote for backup
- Don't delete worktree until merged
```

**Step 3: Commit**

```bash
git add skills/using-git-worktrees/
git commit -m "feat(skills): add using-git-worktrees skill"
```

---

### Task 8: Create Pickup Skill

**Files:**
- Create: `skills/pickup/SKILL.md`

**Step 1: Create skill directory**

```bash
mkdir -p skills/pickup
```

**Step 2: Create SKILL.md**

```markdown
---
name: pickup
description: Pick up a GitHub issue and prepare workspace for implementation. Use when another developer created the issue and you're implementing it.
---

# Pickup Issue

## Overview

Pick up a GitHub issue created by envoy:brainstorming. Creates a worktree, loads the linked spec, and prepares for execution.

**Announce at start:** "I'm using envoy:pickup to prepare this issue for implementation."

## Process

### Step 1: Fetch Issue Details

```bash
gh issue view <issue-number> --json title,body,labels
```

### Step 2: Extract Linked Spec

Parse the issue body to find the spec document path in "Linked Spec" section.

### Step 3: Create Worktree

Use envoy:using-git-worktrees to create isolated workspace:

```bash
# Extract topic from issue title (lowercase, hyphenated)
TOPIC=$(echo "<issue-title>" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -cd '[:alnum:]-')

git worktree add ../envoy-worktrees/$TOPIC -b feature/$TOPIC
cd ../envoy-worktrees/$TOPIC
```

### Step 4: Load Context

1. Read the linked spec document
2. Detect project stack (auto-load stack profiles)
3. Check for existing implementation plan

### Step 5: Report Ready State

"**Workspace ready for issue #<number>**

- Worktree: `../envoy-worktrees/<topic>`
- Branch: `feature/<topic>`
- Spec: `<spec-path>`
- Stack profiles loaded: `<detected-stacks>`

**Next steps:**
1. `/envoy:write-plan` — Create implementation plan (if not exists)
2. `/envoy:execute-plan` — Execute the plan"

## Error Handling

- **Issue not found:** "Issue #<number> not found. Check the issue number."
- **No linked spec:** "Issue has no linked spec. Was it created with /envoy:brainstorm?"
- **Worktree exists:** "Worktree already exists. `cd ../envoy-worktrees/<topic>` to continue."
```

**Step 3: Commit**

```bash
git add skills/pickup/
git commit -m "feat(skills): add pickup skill"
```

---

### Task 9: Create Pickup Command

**Files:**
- Create: `commands/pickup.md`

**Step 1: Create command file**

```markdown
---
description: Pick up a GitHub issue and prepare workspace for implementation
---

# Pickup Command

Use the envoy:pickup skill to prepare issue #$ARGUMENTS for implementation.

If no issue number provided, ask: "Which issue number would you like to pick up?"

You can also run `gh issue list` to show recent issues.
```

**Step 2: Commit**

```bash
git add commands/pickup.md
git commit -m "feat(commands): add pickup command"
```

---

## Phase 2: Execution & Review Skills

### Task 10: Create Executing-Plans Skill

**Files:**
- Create: `skills/executing-plans/SKILL.md`

**Step 1: Create skill directory**

```bash
mkdir -p skills/executing-plans
```

**Step 2: Create SKILL.md**

```markdown
---
name: executing-plans
description: Execute implementation plans with configurable strategies. Use when you have a plan and are ready to implement.
---

# Executing Implementation Plans

## Overview

Execute implementation plans created by envoy:writing-plans. Supports three execution strategies: parallel, batch, and sequential.

**Announce at start:** "I'm using envoy:executing-plans to implement this plan."

## Read the Plan

1. Load the plan document
2. Parse the execution strategy from YAML frontmatter
3. Identify all tasks and their dependencies

## Execution Strategies

### Sequential (Default)

Execute tasks one at a time, in order:

```
For each task:
  1. Announce: "Starting Task N: <name>"
  2. Execute all steps
  3. Verify completion
  4. Commit
  5. Mark task complete
```

### Batch

Execute tasks in groups with checkpoints:

```
For each batch:
  1. Announce: "Starting Batch N: Tasks <list>"
  2. Execute all tasks in batch (can parallelize if independent)
  3. At checkpoint: pause and ask "Batch complete. Review and continue?"
  4. On approval, proceed to next batch
```

### Parallel

Spawn independent agents for tasks:

```
1. Identify independent tasks (no shared files)
2. Spawn subagent per task using Task tool
3. Wait for all to complete
4. Review results
5. Resolve any conflicts
```

## Progress Tracking

Use TodoWrite to track progress:

```
- [ ] Task 1: <name>
- [x] Task 2: <name> (completed)
- [ ] Task 3: <name>
```

## Verification

After each task:
1. Run relevant tests
2. Check for lint errors
3. Verify expected files exist/changed

## Completion

When all tasks complete:

"**Plan execution complete**

- Tasks completed: <N>/<Total>
- Commits made: <N>

**Next steps:**
1. `/envoy:review` — Run 4-layer review
2. `/envoy:finalize` — Prepare PR"
```

**Step 3: Commit**

```bash
git add skills/executing-plans/
git commit -m "feat(skills): add executing-plans skill"
```

---

### Task 11: Create Execute-Plan Command

**Files:**
- Create: `commands/execute-plan.md`

**Step 1: Create command file**

```markdown
---
description: Execute an implementation plan
---

# Execute Plan Command

Use the envoy:executing-plans skill to execute the plan.

If "$ARGUMENTS" contains a file path, use that plan.
Otherwise, look for the most recent plan in `docs/plans/` matching current branch, or ask which one to use.
```

**Step 2: Commit**

```bash
git add commands/execute-plan.md
git commit -m "feat(commands): add execute-plan command"
```

---

### Task 12: Create Layered-Review Skill

**Files:**
- Create: `skills/layered-review/SKILL.md`

**Step 1: Create skill directory**

```bash
mkdir -p skills/layered-review
```

**Step 2: Create SKILL.md**

```markdown
---
name: layered-review
description: Run 4-layer code review (CodeRabbit, AI review, visual verification, doc gaps). Use after implementation before finalizing.
---

# Layered Review Process

## Overview

Comprehensive 4-layer review combining automated tools, documentation-informed AI review, visual verification, and documentation gap detection.

**Announce at start:** "I'm using envoy:layered-review to review these changes."

## Arguments

- `--check-docs` — Deep documentation analysis
- `--no-check-docs` — Skip documentation gap detection
- (default) — Surface-level doc check

## Pre-Review: Load Context

```bash
# Detect stack
# Load relevant stack profiles from stacks/
# Load project standards (.NET_STANDARDS.md, FRONTEND_STANDARDS.md)
# Load wiki pages related to changed files
# Load acceptance criteria from linked issue/spec
```

## Layer 1: CodeRabbit Static Analysis

```bash
coderabbit review --prompt-only --base main
```

**Triage findings:**
- **Obvious fixes** (style, missing error handling, clear bugs) → Fix automatically
- **Ambiguous** (architectural suggestions, preferences) → Ask user

After fixes:
```bash
git add -p
git commit -m "fix: address code review feedback"
```

## Layer 2: Documentation-Informed AI Review

Spawn fresh agent (no implementation context) with:
- `git diff main...HEAD`
- Project standards docs
- Relevant stack profiles
- Acceptance criteria from spec

**Review checklist:**
1. Does implementation match the spec?
2. Does code follow project standards?
3. Are there architectural concerns?
4. Are there security implications?
5. Is error handling appropriate?
6. Are there performance concerns?
7. Is code consistent with existing patterns?

## Layer 3: Visual/Functional Review

Use Chrome DevTools MCP to verify UI changes:

**Step 1: Start application**
```bash
# Backend
cd backend && dotnet run &

# Frontend
cd frontend && npm run dev &
```

**Step 2: Verify pages**

For each affected page:
```
1. navigate_page to URL
2. take_screenshot
3. list_console_messages — check for errors
4. list_network_requests — check for failures
```

**Step 3: Test user flows**

For key acceptance criteria:
```
1. Navigate to starting page
2. fill_form with test data
3. click submit button
4. wait_for expected result
5. take_screenshot of result
```

**Step 4: Report findings**
- Screenshots captured
- Console errors found
- Network failures found
- Acceptance criteria: passed/failed

## Layer 4: Documentation Gap Detection

**Default mode:**
- Missing docstrings on public APIs
- Obvious outdated references

**--check-docs mode:**
- Cross-reference all standards
- Check wiki for coverage
- Suggest new documentation

**Report gaps:**
- Code patterns not in standards
- Features not in wiki
- Outdated docs contradicting code

## Final Report

"**Review Complete**

**Layer 1 (CodeRabbit):** <N> issues found, <N> auto-fixed, <N> need decision
**Layer 2 (AI Review):** <findings summary>
**Layer 3 (Visual):** <screenshots captured>, <errors found>
**Layer 4 (Docs):** <gaps found>

**Action needed:**
- [ ] <ambiguous issue 1>
- [ ] <ambiguous issue 2>

Ready to proceed with `/envoy:finalize`?"
```

**Step 3: Commit**

```bash
git add skills/layered-review/
git commit -m "feat(skills): add layered-review skill"
```

---

### Task 13: Create Visual-Review Skill

**Files:**
- Create: `skills/visual-review/SKILL.md`

**Step 1: Create skill directory**

```bash
mkdir -p skills/visual-review
```

**Step 2: Create SKILL.md**

```markdown
---
name: visual-review
description: Chrome DevTools visual and functional verification. Use to manually verify UI changes work correctly.
---

# Visual Review with Chrome DevTools

## Overview

Verify UI changes using Chrome DevTools MCP integration. Takes screenshots, checks console for errors, verifies network requests, and tests user flows.

**Announce at start:** "I'm using envoy:visual-review to verify the UI changes."

## Prerequisites

- Application running (backend + frontend)
- Chrome DevTools MCP configured

## Process

### Step 1: Start Application

```bash
# Start backend (in background)
cd backend && dotnet run &

# Start frontend (in background)
cd frontend && npm run dev &

# Wait for startup
sleep 5
```

### Step 2: List Available Pages

```
mcp__chrome-devtools__list_pages
```

### Step 3: Navigate and Screenshot

For each page to verify:

```
mcp__chrome-devtools__navigate_page(url: "http://localhost:5173/<path>")
mcp__chrome-devtools__take_screenshot()
```

### Step 4: Check Console

```
mcp__chrome-devtools__list_console_messages()
```

**Flag any:**
- Errors (red)
- Warnings related to changed code
- Failed assertions

### Step 5: Check Network

```
mcp__chrome-devtools__list_network_requests()
```

**Flag any:**
- Failed requests (4xx, 5xx)
- Slow requests (>1s)
- Missing requests (expected but not made)

### Step 6: Test User Flows

For interactive features:

```
# Fill form
mcp__chrome-devtools__fill_form(selector: "#email", value: "test@example.com")

# Click button
mcp__chrome-devtools__click(selector: "#submit-btn")

# Wait for result
mcp__chrome-devtools__wait_for(selector: ".success-message", timeout: 5000)

# Capture result
mcp__chrome-devtools__take_screenshot()
```

### Step 7: Report

"**Visual Review Complete**

**Pages checked:** <list>
**Screenshots:** <count> captured
**Console errors:** <count> (list if any)
**Network failures:** <count> (list if any)
**User flows:** <passed>/<total>

**Issues found:**
- <issue 1>
- <issue 2>

**Recommendation:** <pass/needs fixes>"
```

**Step 3: Commit**

```bash
git add skills/visual-review/
git commit -m "feat(skills): add visual-review skill"
```

---

### Task 14: Create Review Commands

**Files:**
- Create: `commands/review.md`
- Create: `commands/quick-review.md`
- Create: `commands/visual-review.md`

**Step 1: Create review.md**

```markdown
---
description: Run full 4-layer code review
---

# Review Command

Use the envoy:layered-review skill to run a comprehensive review.

Pass through any flags: $ARGUMENTS (e.g., --check-docs, --no-check-docs)
```

**Step 2: Create quick-review.md**

```markdown
---
description: Run quick review (CodeRabbit + AI only, skip visual)
---

# Quick Review Command

Use the envoy:layered-review skill but only run Layers 1 and 2:
- Layer 1: CodeRabbit static analysis
- Layer 2: Documentation-informed AI review

Skip Layer 3 (visual) and Layer 4 (doc gaps) for faster review of non-UI changes.
```

**Step 3: Create visual-review.md**

```markdown
---
description: Run Chrome DevTools visual verification only
---

# Visual Review Command

Use the envoy:visual-review skill to verify UI changes.

If "$ARGUMENTS" contains URLs or paths, verify those specific pages.
Otherwise, detect changed frontend files and verify affected pages.
```

**Step 4: Commit**

```bash
git add commands/review.md commands/quick-review.md commands/visual-review.md
git commit -m "feat(commands): add review commands"
```

---

### Task 15: Create Verification Skill

**Files:**
- Create: `skills/verification/SKILL.md`

**Step 1: Create skill directory**

```bash
mkdir -p skills/verification
```

**Step 2: Create SKILL.md**

```markdown
---
name: verification
description: Verify changes work before claiming done. Use before committing fixes or completing tasks.
---

# Verification Before Completion

## Overview

Never claim something is fixed or working without verification. Run tests, check the actual behavior, provide evidence.

**Announce at start:** "I'm using envoy:verification to verify these changes work."

## Verification Checklist

### For Code Changes

- [ ] Relevant tests pass
- [ ] No new lint errors
- [ ] Application builds successfully
- [ ] Changed functionality works as expected

### For Bug Fixes

- [ ] Bug is reproducible before fix (or was)
- [ ] Bug no longer occurs after fix
- [ ] No regression in related functionality
- [ ] Test added to prevent regression

### For New Features

- [ ] Feature works as specified
- [ ] Edge cases handled
- [ ] Error states handled gracefully
- [ ] Tests cover happy path and edge cases

## Commands

**Run backend tests:**
```bash
cd backend && dotnet test
```

**Run frontend tests:**
```bash
cd frontend && npm test
```

**Run E2E tests:**
```bash
cd frontend && npm run test:e2e
```

**Check lint:**
```bash
cd frontend && npm run lint
cd backend && dotnet build
```

## Report

"**Verification Complete**

- Backend tests: PASS/FAIL
- Frontend tests: PASS/FAIL
- Lint: PASS/FAIL
- Build: PASS/FAIL

**Evidence:** <describe what was verified>

Ready to commit/proceed."
```

**Step 3: Commit**

```bash
git add skills/verification/
git commit -m "feat(skills): add verification skill"
```

---

## Phase 3: Finalization Skills

### Task 16: Create Finishing-Branch Skill

**Files:**
- Create: `skills/finishing-branch/SKILL.md`

**Step 1: Create skill directory**

```bash
mkdir -p skills/finishing-branch
```

**Step 2: Create SKILL.md**

```markdown
---
name: finishing-branch
description: Complete a development branch with review, docstrings, wiki sync, and PR. Use when implementation is done.
---

# Finishing a Development Branch

## Overview

Complete workflow for finishing implementation: run review, add docstrings, sync wiki, create PR.

**Announce at start:** "I'm using envoy:finishing-branch to prepare this work for PR."

## Preconditions

Before starting, verify:
1. On a feature branch (not main/master)
2. Tests pass
3. Working directory is clean

```bash
git branch --show-current  # Not main/master
git status --porcelain     # Should be empty
dotnet test                # Should pass
npm test                   # Should pass
```

## Process

### Step 1: Run Review

Use envoy:layered-review for full 4-layer review.

Fix any issues found before proceeding.

### Step 2: Add Docstrings

Use envoy:docstrings to add documentation to public APIs.

### Step 3: Update Wiki

Use envoy:wiki-sync to sync documentation.

### Step 4: Create PR

```bash
# Push branch
git push -u origin HEAD

# Get PR format from existing PRs
gh pr list --limit 5 --state merged --json title,body

# Create PR
gh pr create --title "<title>" --body "$(cat <<'EOF'
## Summary

<Brief description>

## Changes

- Implementation: <summary>
- Code review: <issues addressed>
- Documentation: <what was updated>

## Test Plan

<How this was tested>

## Linked Issue

Closes #<issue-number>

---

*Created with Envoy*
EOF
)"
```

### Step 5: Report

"**Branch finalized**

- PR: <url>
- Wiki: synced
- Docstrings: added
- Review: passed

Ready for merge after CI passes."
```

**Step 3: Commit**

```bash
git add skills/finishing-branch/
git commit -m "feat(skills): add finishing-branch skill"
```

---

### Task 17: Create Finalize Command

**Files:**
- Create: `commands/finalize.md`

**Step 1: Create command file**

```markdown
---
description: Finalize implementation with review, docs, and PR
---

# Finalize Command

Use the envoy:finishing-branch skill to complete this branch.

This will:
1. Run 4-layer review
2. Add docstrings to public APIs
3. Sync wiki documentation
4. Create pull request
```

**Step 2: Commit**

```bash
git add commands/finalize.md
git commit -m "feat(commands): add finalize command"
```

---

### Task 18: Create Wiki-Sync Skill

**Files:**
- Create: `skills/wiki-sync/SKILL.md`

**Step 1: Create skill directory**

```bash
mkdir -p skills/wiki-sync
```

**Step 2: Create SKILL.md**

```markdown
---
name: wiki-sync
description: Sync docs/wiki/ to GitHub wiki. Use after updating documentation or as part of finalization.
---

# Wiki Sync

## Overview

Sync contents of `docs/wiki/` to the GitHub wiki repository.

**Announce at start:** "I'm using envoy:wiki-sync to sync documentation to GitHub wiki."

## Process

### Step 1: Check for docs/wiki/

```bash
ls docs/wiki/
```

If directory doesn't exist or is empty, report and exit.

### Step 2: Get Repository Info

```bash
REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner)
WIKI_PATH=~/.cache/wiki-repos/$(echo $REPO | tr '/' '-').wiki
```

### Step 3: Clone/Update Wiki Repo

```bash
if [ -d "$WIKI_PATH" ]; then
  cd "$WIKI_PATH"
  git pull origin master --rebase 2>/dev/null || true
else
  mkdir -p ~/.cache/wiki-repos
  git clone git@github.com:${REPO}.wiki.git "$WIKI_PATH" 2>/dev/null || {
    mkdir -p "$WIKI_PATH"
    cd "$WIKI_PATH"
    git init
    git remote add origin git@github.com:${REPO}.wiki.git
  }
fi
```

### Step 4: Sync Files

```bash
cd "$WIKI_PATH"
cp -r /path/to/project/docs/wiki/* .
```

### Step 5: Check for Conflicts

```bash
git status
```

If wiki has changes not in docs/wiki/, ask user:
"GitHub wiki has changes not in docs/wiki/. Should I overwrite with docs/wiki/ or merge manually?"

### Step 6: Commit and Push

```bash
git add -A
git commit -m "docs: sync from main repo" || echo "No changes to sync"
git push origin master 2>/dev/null || git push --set-upstream origin master
```

### Step 7: Report

"**Wiki synced**

- Files synced: <list>
- Status: pushed to GitHub wiki"
```

**Step 3: Commit**

```bash
git add skills/wiki-sync/
git commit -m "feat(skills): add wiki-sync skill"
```

---

### Task 19: Create Wiki-Sync Command

**Files:**
- Create: `commands/wiki-sync.md`

**Step 1: Create command file**

```markdown
---
description: Sync docs/wiki/ to GitHub wiki
---

# Wiki Sync Command

Use the envoy:wiki-sync skill to sync documentation.
```

**Step 2: Commit**

```bash
git add commands/wiki-sync.md
git commit -m "feat(commands): add wiki-sync command"
```

---

### Task 20: Create Docstrings Skill

**Files:**
- Create: `skills/docstrings/SKILL.md`

**Step 1: Create skill directory**

```bash
mkdir -p skills/docstrings
```

**Step 2: Create SKILL.md**

```markdown
---
name: docstrings
description: Add docstrings to public APIs. Use after implementation or as standalone documentation task.
---

# Add Docstrings

## Overview

Add documentation to public APIs in files changed on this branch.

**Announce at start:** "I'm using envoy:docstrings to document public APIs."

## Scope

Find files changed since base branch:

```bash
git diff --name-only main...HEAD
```

## Conventions

### C# (XML Docs)

```csharp
/// <summary>
/// Brief description of what the method does.
/// </summary>
/// <param name="paramName">Description of parameter.</param>
/// <returns>Description of return value.</returns>
/// <exception cref="ExceptionType">When this exception is thrown.</exception>
public ReturnType MethodName(ParamType paramName)
```

### TypeScript (JSDoc)

```typescript
/**
 * Brief description of what the function does.
 * @param paramName - Description of parameter.
 * @returns Description of return value.
 * @throws {ErrorType} When this error is thrown.
 */
export function functionName(paramName: ParamType): ReturnType
```

## Process

For each changed file:

1. Identify public classes, methods, functions
2. Check if documentation exists
3. Add/update docstrings following project conventions
4. Include parameter descriptions and return values

## Commit

```bash
git add -p  # Review staged changes
git commit -m "docs: add docstrings to public APIs"
```

## Report

"**Docstrings added**

- Files documented: <list>
- Public APIs documented: <count>

Ready to continue."
```

**Step 3: Commit**

```bash
git add skills/docstrings/
git commit -m "feat(skills): add docstrings skill"
```

---

### Task 21: Create Docstrings Command

**Files:**
- Create: `commands/docstrings.md`

**Step 1: Create command file**

```markdown
---
description: Add docstrings to public APIs
---

# Docstrings Command

Use the envoy:docstrings skill to add documentation.

If "$ARGUMENTS" contains file paths, document those specific files.
Otherwise, document files changed since main branch.
```

**Step 2: Commit**

```bash
git add commands/docstrings.md
git commit -m "feat(commands): add docstrings command"
```

---

## Phase 4: Stack Profiles (Core)

### Task 22: Create .NET Stack Profile

**Files:**
- Create: `stacks/dotnet.md`

**Step 1: Create stack profile**

See design document Section 9 for full template. Create `stacks/dotnet.md` with:
- Overview
- Best Practices (async/await, DI, repository pattern, etc.)
- Common Mistakes to Check
- Review Checklist
- Code Examples (good and anti-patterns)
- References

**Step 2: Commit**

```bash
git add stacks/dotnet.md
git commit -m "feat(stacks): add .NET stack profile"
```

---

### Task 23: Create React Stack Profile

**Files:**
- Create: `stacks/react.md`

**Step 1: Create stack profile with:**
- React 19 patterns
- Component structure
- State management with React Query
- Common mistakes (unnecessary re-renders, missing keys, etc.)
- Review checklist

**Step 2: Commit**

```bash
git add stacks/react.md
git commit -m "feat(stacks): add React stack profile"
```

---

### Task 24: Create TypeScript Stack Profile

**Files:**
- Create: `stacks/typescript.md`

**Step 1: Create stack profile with:**
- TypeScript 5.9 standards
- Strict mode configuration
- Type inference best practices
- Common mistakes
- Review checklist

**Step 2: Commit**

```bash
git add stacks/typescript.md
git commit -m "feat(stacks): add TypeScript stack profile"
```

---

### Task 25: Create PostgreSQL Stack Profile

**Files:**
- Create: `stacks/postgresql.md`

**Step 1: Create stack profile with:**
- Query optimization
- Index usage
- Connection pooling
- Common mistakes (N+1, missing indexes)
- Review checklist

**Step 2: Commit**

```bash
git add stacks/postgresql.md
git commit -m "feat(stacks): add PostgreSQL stack profile"
```

---

### Task 26-36: Create Remaining Stack Profiles

Create each remaining stack profile following the same pattern:

26. `stacks/entity-framework.md`
27. `stacks/serilog.md`
28. `stacks/jwt-oauth.md`
29. `stacks/api-patterns.md`
30. `stacks/shadcn-radix.md`
31. `stacks/react-query.md`
32. `stacks/react-hook-form.md`
33. `stacks/tailwind.md`
34. `stacks/orval.md`
35. `stacks/testing-dotnet.md`
36. `stacks/testing-playwright.md`

Commit each: `git commit -m "feat(stacks): add <name> stack profile"`

---

### Task 37-42: Create Infrastructure Stack Profiles

37. `stacks/docker-compose.md`
38. `stacks/azure.md`
39. `stacks/azure-container-apps.md`
40. `stacks/azure-static-web-apps.md`
41. `stacks/azure-postgresql.md`
42. `stacks/bicep.md`
43. `stacks/github-actions.md`
44. `stacks/security.md`
45. `stacks/application-insights.md`

Commit each: `git commit -m "feat(stacks): add <name> stack profile"`

---

## Phase 5: Polish

### Task 46: Create Templates

**Files:**
- Create: `templates/github-issue.md`
- Create: `templates/spec-doc.md`
- Create: `templates/plan-doc.md`

**Step 1: Create templates based on design document sections 6 and writing-plans skill.**

**Step 2: Commit**

```bash
git add templates/
git commit -m "feat(templates): add issue, spec, and plan templates"
```

---

### Task 47: Create README

**Files:**
- Create: `README.md`

**Step 1: Create README with:**
- Overview
- Installation
- Quick Start
- Available Commands
- Skills Reference
- Stack Profiles
- Contributing

**Step 2: Commit**

```bash
git add README.md
git commit -m "docs: add README"
```

---

### Task 48: Final Verification

**Step 1: Test plugin loads**

```bash
claude --plugin-dir .
```

**Step 2: Test a command**

```
/envoy:brainstorm "test feature"
```

**Step 3: Verify all files exist**

```bash
find . -name "*.md" | wc -l
```

Expected: 40+ markdown files

---

## Execution Configuration

```yaml
execution:
  strategy: batch
  batches:
    - name: "Phase 1: Foundation"
      tasks: [1, 2, 3, 4, 5, 6, 7, 8, 9]
      checkpoint: true
    - name: "Phase 2: Execution & Review"
      tasks: [10, 11, 12, 13, 14, 15]
      checkpoint: true
    - name: "Phase 3: Finalization"
      tasks: [16, 17, 18, 19, 20, 21]
      checkpoint: true
    - name: "Phase 4: Stack Profiles"
      tasks: [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45]
      checkpoint: true
    - name: "Phase 5: Polish"
      tasks: [46, 47, 48]
      checkpoint: false
```

---

*Plan created on 2026-01-17 from design document `2026-01-17-envoy-plugin-design.md`*
